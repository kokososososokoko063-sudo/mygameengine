<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ù…Ø­Ø±Ù‘Ùƒ TinyGameLang â€” Ù…Ø­Ø±Ø± + PixiJS</title>

  <!-- Tailwind via CDN (Ø³Ù‡Ù„ Ù„Ù„ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø³Ø±ÙŠØ¹Ø©) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* ØªØ­Ø³ÙŠÙ† Ù…Ø¸Ù‡Ø± Font Ùˆ scrollbar Ø¨Ø³ÙŠØ· */
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .cm-editor { height: 320px; border-radius: .5rem; overflow: hidden; }
    /* Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø³ÙŠØ·Ø© Ù„Ù„Ù€ editor container Ù„Ùˆ Ø§Ø­ØªØ¬Øª fallback */
    #examples { max-height: 10rem; overflow:auto; }
  </style>
</head>
<body class="bg-gray-50 min-h-screen p-6">

  <div class="max-w-6xl mx-auto">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">ğŸ® Ù…Ø­Ø±Ù‘Ùƒ TinyGameLang â€” Ù…Ø­Ø±Ø± + Ø¹Ø±Ø¶ (PixiJS)</h1>
      <p class="text-sm text-gray-600">Ù†Ø³Ø®Ø© Ù…ÙˆØ³Ø¹Ø©: Ù…Ø­Ø±Ø± CodeMirror 6 + PixiJS + Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ + ØªØµØ¯ÙŠØ±/Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø£Ù…Ø«Ù„Ø©.</p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Ø§Ù„Ù…Ø­Ø±Ø± ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª -->
      <section class="space-y-4">
        <div class="bg-white p-4 rounded-2xl shadow">
          <div class="flex items-start justify-between gap-3">
            <div>
              <h2 class="font-semibold">Ø§Ù„Ù…Ø­Ø±Ø±</h2>
              <p class="text-xs text-gray-500">Ø§ÙƒØªØ¨ ÙƒÙˆØ¯ TinyGameLang Ø«Ù… Ø§Ø¶ØºØ· Run</p>
            </div>

            <div class="flex gap-2">
              <button id="runBtn" class="px-3 py-1 bg-green-600 text-white rounded">ØªØ´ØºÙŠÙ„</button>
              <button id="stopBtn" class="px-3 py-1 bg-red-500 text-white rounded">Ø¥ÙŠÙ‚Ø§Ù</button>
              <button id="saveBtn" class="px-3 py-1 bg-blue-600 text-white rounded">Ø­ÙØ¸ ÙŠØ¯ÙˆÙŠ</button>
              <button id="downloadBtn" class="px-3 py-1 bg-gray-200 rounded">ØªÙ†Ø²ÙŠÙ„ .tiny</button>
              <label class="cursor-pointer px-3 py-1 bg-gray-200 rounded">
                ØªØ­Ù…ÙŠÙ„
                <input id="uploadFile" type="file" accept=".tiny,.txt" class="hidden" />
              </label>
            </div>
          </div>

          <div id="editor" class="mt-3 cm-editor border border-gray-200"></div>

          <div class="mt-3 flex gap-2 items-center">
            <select id="examples" class="px-3 py-1 rounded border">
              <option value="">â€” Ø§Ø®ØªØ± Ù…Ø«Ø§Ù„Ø§Ù‹ â€”</option>
              <option value="basic">Ù…Ø«Ø§Ù„: Ø­Ø±ÙƒØ© Ø¨Ø³ÙŠØ·Ø©</option>
              <option value="background">Ù…Ø«Ø§Ù„: Ø®Ù„ÙÙŠØ© ÙˆÙ†Øµ</option>
              <option value="circle">Ù…Ø«Ø§Ù„: Ø¯Ø§Ø¦Ø±Ø© Ù…ØªØ­Ø±ÙƒØ©</option>
            </select>
            <button id="loadExample" class="px-3 py-1 bg-indigo-600 text-white rounded">ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„</button>

            <div class="mr-auto text-sm text-gray-500">Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙŠØ¹Ù…Ù„ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ.</div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ù…Ø®Ø±Ø¬Ø§Øª / Console</h3>
          <pre id="console" class="mt-2 bg-black text-green-300 p-3 rounded h-28 overflow-auto">â€”</pre>
          <div class="mt-3 text-xs text-gray-500">Ø£Ø®Ø·Ø§Ø¡ Ø²Ù…Ù† Ø§Ù„ØªØ´ØºÙŠÙ„ ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§.</div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ø®ØªØµØ±Ø© Ù„Ù„Ù€ TinyGameLang</h3>
          <ul class="list-disc pr-5 mt-2 text-sm leading-7">
            <li><code>player at X Y</code> â€” Ø¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª</li>
            <li><code>color player NAME</code> â€” Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø§Ø³Ù… Ø£Ùˆ #hex)</li>
            <li><code>rect player W H</code> â€” Ø­Ø¬Ù… Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„</li>
            <li><code>circle player R</code> â€” Ø§Ø¹Ù…Ù„ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¯Ø§Ø¦Ø±Ø© Ø¨Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±</li>
            <li><code>move player DX DY</code> â€” ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ù…Ø¨Ø§Ø´Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø©)</li>
            <li><code>loop N ... end</code> â€” ÙƒØ±Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø© N Ù…Ø±Ø©</li>
            <li><code>background COLOR</code> â€” ØºÙŠÙ‘Ø± Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©</li>
            <li><code>say \"text\"</code> â€” Ø¹Ø±Ø¶ Ù†Øµ (ÙƒÙ†Øµ Pixi)</li>
          </ul>
        </div>
      </section>

      <!-- Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¨ØµØ±ÙŠØ© -->
      <section class="space-y-4">
        <div class="bg-white p-4 rounded-2xl shadow">
          <div class="flex items-center justify-between">
            <h2 class="font-semibold">Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (PixiJS)</h2>
            <div class="flex gap-2 items-center">
              <label class="flex items-center gap-2 text-sm">
                Ø­Ø¬Ù… Ø§Ù„Ø¹Ø±Ø¶
                <select id="sizeSelect" class="px-2 py-1 rounded border">
                  <option value="480x320">480Ã—320</option>
                  <option value="640x360">640Ã—360</option>
                  <option value="800x450">800Ã—450</option>
                </select>
              </label>
              <label class="flex items-center gap-2 text-sm">
                FPS:
                <span id="fps" class="ml-2 text-xs text-gray-500">â€”</span>
              </label>
            </div>
          </div>

          <div id="stageWrap" class="mt-3 border border-gray-200 rounded overflow-hidden" style="background:#ffffff">
            <!-- PIXI will attach here -->
            <div id="pixiContainer" style="width:100%;height:320px"></div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ø®ÙŠØ§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</h3>
          <div class="mt-3 grid grid-cols-2 gap-3">
            <label class="flex items-center gap-2"><input id="autoSaveToggle" type="checkbox" checked/> Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ</label>
            <label class="flex items-center gap-2">Ø³Ø±Ø¹Ø© Ø§Ù„ØªÙ†ÙÙŠØ°: <input id="speedRange" type="range" min="1" max="4" value="1" step="0.1" /></label>
            <label class="flex items-center gap-2">ØªØµÙÙŠØ± Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ <button id="clearConsole" class="px-2 py-1 bg-gray-200 rounded">Ù…Ø³Ø­</button></label>
            <div></div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow text-sm text-gray-600">
          <strong>Ù…Ù„Ø§Ø­Ø¸Ø© Ù†Ø´Ø±:</strong> Ø§Ù„Ù…Ù„Ù ÙˆØ§Ø­Ø¯ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø±ÙØ¹ Ø¹Ù„Ù‰ GitHub Pages. Ø¨Ø¹Ø¯ Ø±ÙØ¹Ù‡ Ø¥Ù„Ù‰
          Ù…Ø³ØªÙˆØ¯Ø¹ØŒ ÙØ¹Ù‘Ù„ Pages (Ø§Ù„ÙØ±Ø¹: mainØŒ Ø§Ù„Ù…ØµØ¯Ø±: /) ÙˆØ³ØªØ¬Ø¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¹Ù„Ù‰:
          <code class="block">https://username.github.io/your-repo-name/</code>
        </div>
      </section>
    </main>
  </div>

  <!-- PixiJS (Classic UMD) -->
  <script src="https://pixijs.download/release/pixi.min.js"></script>

  <!-- CodeMirror 6 (ES Modules) - basic parts to run an editor -->
  <script type="module">
    import { EditorState } from "https://cdn.jsdelivr.net/npm/@codemirror/state@6.3.1/+esm";
    import { EditorView, minimalSetup } from "https://cdn.jsdelivr.net/npm/@codemirror/basic-setup@0.19.1/+esm";
    import { defaultHighlightStyle } from "https://cdn.jsdelivr.net/npm/@codemirror/highlight@0.19.6/+esm";

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø±Ø±
    const startCode = `// Ù…Ø«Ø§Ù„ Ù…ÙˆØ³Ù‘Ø¹: TinyGameLang
background #222
player at 50 140
color player cyan
rect player 24 24
say "Ù…Ø±Ø­Ø¨Ø§Ù‹!"
loop 120
  move player 2 0
end
`;

    const editorParent = document.getElementById('editor');
    const state = EditorState.create({
      doc: localStorage.getItem('tiny.code') || startCode,
      extensions: [
        minimalSetup,
        defaultHighlightStyle,
        EditorView.lineWrapping
      ]
    });
    const view = new EditorView({
      state,
      parent: editorParent
    });

    // ÙˆØ§Ø¬Ù‡Ø© ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø¨Ù‚ÙŠØ© Ø§Ù„Ø³ÙƒØ±Ø¨Øª
    window.__TinyEditor = {
      getCode: () => view.state.doc.toString(),
      setCode: (text) => {
        view.dispatch({ changes: { from: 0, to: view.state.doc.length, insert: text } });
      }
    };
  </script>

  <!-- Runtime + Compiler TinyGameLang -->
  <script>
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†Ø§ØµØ± DOM
    const runBtn = document.getElementById('runBtn');
    const stopBtn = document.getElementById('stopBtn');
    const saveBtn = document.getElementById('saveBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const uploadFile = document.getElementById('uploadFile');
    const loadExampleBtn = document.getElementById('loadExample');
    const examplesSelect = document.getElementById('examples');
    const consoleEl = document.getElementById('console');
    const autoSaveToggle = document.getElementById('autoSaveToggle');
    const sizeSelect = document.getElementById('sizeSelect');
    const pixiContainer = document.getElementById('pixiContainer');
    const fpsEl = document.getElementById('fps');
    const clearConsoleBtn = document.getElementById('clearConsole');
    const speedRange = document.getElementById('speedRange');

    // Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    let app = null;
    let tickerHandle = null;
    let runtimeState = { running: false, fps: 0, speed: 1 };

    // Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø©
    function logConsole(msg) {
      consoleEl.textContent += msg + '\\n';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }
    function clearConsole() { consoleEl.textContent = ''; }

    // Ø£Ù…Ø«Ù„Ø© Ø¬Ø§Ù‡Ø²Ø©
    const examples = {
      basic: `// Ø­Ø±ÙƒØ© Ø¨Ø³ÙŠØ·Ø©
background #111
player at 50 140
color player orange
rect player 24 24
loop 200
  move player 3 0
end
`,
      background: `background blue
player at 20 40
color player white
rect player 24 24
say "Ø®Ù„ÙÙŠØ© Ø²Ø±Ù‚Ø§Ø¡"
loop 120
  move player 2 0
end
`,
      circle: `background #0b0b0b
player at 100 150
color player #f0f
circle player 16
loop 180
  move player 2 0
end
`
    };

    // ØªØ­Ù…ÙŠÙ„ Ù…Ø«Ø§Ù„
    loadExampleBtn.addEventListener('click', () => {
      const key = examplesSelect.value;
      if (!key) return alert('Ø§Ø®ØªØ± Ù…Ø«Ø§Ù„Ø§Ù‹');
      window.__TinyEditor.setCode(examples[key] || '');
    });

    // Ø­ÙØ¸/ØªØ­Ù…ÙŠÙ„ Ù…Ø­Ù„ÙŠ
    saveBtn.addEventListener('click', () => {
      const code = window.__TinyEditor.getCode();
      localStorage.setItem('tiny.code', code);
      logConsole('ØªÙ… Ø§Ù„Ø­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹');
    });

    // ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù .tiny
    uploadFile.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        window.__TinyEditor.setCode(String(reader.result));
      };
      reader.readAsText(f);
    });

    // ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ù„Ù
    downloadBtn.addEventListener('click', () => {
      const code = window.__TinyEditor.getCode();
      const blob = new Blob([code], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'project.tiny';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ø¥Ø°Ø§ Ù…ÙØ¹Ù„
    setInterval(() => {
      if (autoSaveToggle.checked) {
        const code = window.__TinyEditor.getCode();
        localStorage.setItem('tiny.code', code);
        // Ù„Ø§ Ù†Ø·Ø¨Ø¹ ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ ÙƒÙ„ Ù…Ø±Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ÙÙˆØ¶Ù‰
      }
    }, 5000);

    // Ù…Ø³Ø­ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„
    clearConsoleBtn.addEventListener('click', clearConsole);

    // ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø¹Ø±Ø¶
    sizeSelect.addEventListener('change', () => {
      const v = sizeSelect.value.split('x');
      resizeStage(parseInt(v[0]), parseInt(v[1]));
    });

    // Ø³Ø±Ø¹Ø© Ø§Ù„ØªÙ†ÙÙŠØ° (Ù…Ø¹Ø¯Ù„ Ø­Ø±ÙƒØ©)
    speedRange.addEventListener('input', () => {
      runtimeState.speed = Number(speedRange.value);
    });

    // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ´ØºÙŠÙ„
    stopBtn.addEventListener('click', stopRuntime);

    // ØªØ´ØºÙŠÙ„
    runBtn.addEventListener('click', () => {
      stopRuntime(); // Ø£ÙˆÙ‚Ù Ø£ÙŠ Ø´ÙŠØ¡ Ø´ØºØ§Ù„ Ø³Ø§Ø¨Ù‚Ø§Ù‹
      clearConsole();
      const code = window.__TinyEditor.getCode();
      try {
        startRuntime(code);
      } catch (e) {
        logConsole('Ø®Ø·Ø£: ' + e.message);
      }
    });

    // =========================
    // TinyGameLang Compiler (Ù…ØªØ±Ø¬Ù… Ø¨Ø³ÙŠØ· ÙŠÙ†ØªØ¬ AST Ø¯Ø§Ø®Ù„ÙŠ)
    // =========================
    function parseTiny(src) {
      // Ù†Ø¹ÙŠØ¯ Ù…ØµÙÙˆÙØ© Ø£ÙˆØ§Ù…Ø± Ø¨Ø³ÙŠØ·Ø© (AST Ø®ÙÙŠÙ)
      const lines = src.split(/\\r?\\n/);
      const cmds = [];
      const stack = [];
      for (let rawLine of lines) {
        const line = rawLine.trim();
        if (!line || line.startsWith('//')) continue;
        // quotes handling for say "text"
        const sayMatch = line.match(/^say\\s+"(.*)"$/i);
        if (sayMatch) {
          cmds.push({ t: 'say', text: sayMatch[1] });
          continue;
        }
        const parts = line.split(/\\s+/);
        const first = parts[0].toLowerCase();

        if (first === 'loop') {
          const n = Number(parts[1]) || 0;
          const node = { t: 'loop', n, body: [] };
          cmds.push(node);
          stack.push(node);
          continue;
        }
        if (first === 'end') {
          stack.pop();
          continue;
        }

        const node = (() => {
          // handle background
          if (first === 'background') return { t: 'background', color: parts[1] };
          if (first === 'player' && parts[1] === 'at') return { t: 'player_at', x: Number(parts[2]), y: Number(parts[3]) };
          if (first === 'color' && parts[1] === 'player') return { t: 'color_player', color: parts[2] };
          if (first === 'rect' && parts[1] === 'player') return { t: 'rect_player', w: Number(parts[2]), h: Number(parts[3]) };
          if (first === 'circle' && parts[1] === 'player') return { t: 'circle_player', r: Number(parts[2]) };
          if (first === 'move' && parts[1] === 'player') return { t: 'move_player', dx: Number(parts[2]), dy: Number(parts[3]) };
          // fallback unknown
          return { t: 'unknown', raw: line };
        })();

        if (stack.length > 0) {
          stack[stack.length - 1].body.push(node);
        } else {
          cmds.push(node);
        }
      }
      return cmds;
    }

    // =========================
    // Runtime using PixiJS
    // =========================
    function createPixiApp(width = 480, height = 320) {
      // Ù†Ø¸ÙŠÙØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‚Ø§Ø¦Ù…
      if (app) {
        app.destroy(true, { children: true });
        app = null;
      }
      // Create Pixi Application
      app = new PIXI.Application({
        width, height,
        backgroundColor: 0x000000,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true
      });
      // Attach
      pixiContainer.innerHTML = '';
      pixiContainer.appendChild(app.view);
      return app;
    }

    function resizeStage(w, h) {
      if (!app) {
        createPixiApp(w, h);
      } else {
        app.renderer.resize(w, h);
      }
      app.renderer.view.style.width = '100%';
      app.renderer.view.style.height = '320px';
    }

    // Convert color string to hex for Pixi
    function colorToHex(c) {
      if (!c) return 0xffffff;
      // handle #hex
      if (c.startsWith('#')) return parseInt(c.slice(1), 16);
      // simple names â€” a minimal map
      const map = {
        red: 0xff0000, green: 0x00ff00, blue: 0x0000ff, white: 0xffffff, black: 0x000000,
        cyan: 0x00ffff, orange: 0xffa500, yellow: 0xffff00, magenta: 0xff00ff, gray: 0x808080
      };
      if (map[c.toLowerCase()]) return map[c.toLowerCase()];
      // fallback white
      return 0xffffff;
    }

    // flatten commands into a sequence of frames (simple execution model)
    function flattenCommands(cmds) {
      // We'll produce an array of frame-actions: each frame is a list of ops
      // loop N will duplicate its body N times
      const frames = [];
      function pushOps(list) {
        for (const node of list) {
          if (node.t === 'loop') {
            for (let i = 0; i < node.n; i++) {
              pushOps(node.body);
            }
          } else {
            frames.push(node);
          }
        }
      }
      pushOps(cmds);
      return frames;
    }

    function startRuntime(code) {
      // Parse
      const ast = parseTiny(code);
      // initial stage size
      const size = sizeSelect.value.split('x').map(Number);
      createPixiApp(size[0], size[1]);
      const stage = app.stage;
      // stateful objects
      const player = {
        g: new PIXI.Graphics(),
        x: 0, y: 0, w: 24, h: 24, r: null, color: 0xffffff, text: null
      };
      stage.addChild(player.g);

      // background
      let bgColor = 0x000000;
      app.renderer.backgroundColor = bgColor;

      // text objects
      const texts = [];

      // flatten into frames
      const frames = flattenCommands(ast);

      // pointer to frame index
      let pc = 0;

      function applyNode(node) {
        switch (node.t) {
          case 'background':
            bgColor = colorToHex(node.color);
            app.renderer.backgroundColor = bgColor;
            break;
          case 'player_at':
            player.x = node.x;
            player.y = node.y;
            break;
          case 'color_player':
            player.color = colorToHex(node.color);
            break;
          case 'rect_player':
            player.w = node.w || player.w;
            player.h = node.h || player.h;
            player.r = null;
            break;
          case 'circle_player':
            player.r = node.r || player.r;
            if (player.r) { player.w = player.h = player.r * 2; }
            break;
          case 'move_player':
            player.x += node.dx * runtimeState.speed;
            player.y += node.dy * runtimeState.speed;
            break;
          case 'say':
            // create a PIXI.Text and place it above player
            const t = new PIXI.Text(node.text, { fontSize: 16, fill: 0xffffff });
            t.x = player.x;
            t.y = player.y - 30;
            stage.addChild(t);
            texts.push({ obj: t, ttl: 120 }); // live 120 frames
            break;
          case 'unknown':
            logConsole('ØªØ¹Ø°Ø± ØªÙ†ÙÙŠØ° Ø§Ù„Ø³Ø·Ø±: ' + node.raw);
            break;
        }
      }

      // initial pass: apply non-motion nodes that set initial state until first move or so
      // but our frames array is sequential; we'll just play it: each frame triggers applyNode
      runtimeState.running = true;

      // ticker for animation
      let last = performance.now();
      let frameCount = 0;
      let fpsTime = 0;

      app.ticker.maxFPS = 60;
      app.ticker.add(() => {
        if (!runtimeState.running) return;
        const now = performance.now();
        const dt = now - last;
        last = now;

        // execute a chunk: to keep UI responsive we execute some nodes per tick
        // execute up to 2 nodes per tick scaled by speed
        const perTick = Math.max(1, Math.round(1 * runtimeState.speed));
        for (let k = 0; k < perTick; k++) {
          if (pc >= frames.length) break;
          const node = frames[pc++];
          applyNode(node);
        }

        // update player graphics
        player.g.clear();
        player.g.beginFill(player.color || 0xffffff);
        if (player.r) {
          player.g.drawCircle(player.x + player.r, player.y + player.r, player.r);
        } else {
          player.g.drawRect(player.x, player.y, player.w, player.h);
        }
        player.g.endFill();

        // update texts lifetime
        for (let i = texts.length - 1; i >= 0; i--) {
          texts[i].ttl--;
          const t = texts[i].obj;
          if (t) {
            t.x = player.x;
            t.y = player.y - 30;
          }
          if (texts[i].ttl <= 0) {
            stage.removeChild(texts[i].obj);
            texts.splice(i, 1);
          }
        }

        // if reached end, stop
        if (pc >= frames.length) {
          runtimeState.running = false;
          logConsole('Ø§Ù†ØªÙ‡Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª');
        }

        // FPS display (low-cost)
        frameCount++;
        fpsTime += dt;
        if (fpsTime >= 500) {
          const fps = Math.round((frameCount / fpsTime) * 1000);
          fpsEl.textContent = fps + ' fps';
          frameCount = 0;
          fpsTime = 0;
        }
      });

      logConsole('Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ â€” ' + frames.length + ' Ø¹Ù…Ù„ÙŠØ©');
      // store runtime in global for stop
      runtimeState._pc = pc;
      runtimeState._frames = frames;
      runtimeState._player = player;
      runtimeState._texts = texts;
    }

    function stopRuntime() {
      runtimeState.running = false;
      if (app) {
        app.ticker.stop();
        // keep the stage visible but stop changes
      }
      logConsole('Ø£ÙÙˆÙ‚Ù Ø§Ù„ØªÙ†ÙÙŠØ°');
    }

    // Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©: Ø§Ø­Ù…Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† LocalStorage (ØªÙ…Ù‘Øª Ø¨Ø§Ù„ÙØ¹Ù„ Ø¯Ø§Ø®Ù„ CodeMirror init)
    logConsole('Ø¬Ø§Ù‡Ø² â€” Ø¹Ø¯Ù‘Ù„ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ§Ø¶ØºØ· ØªØ´ØºÙŠÙ„');

    // Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ø§ÙØªØ­ Ù…Ø«Ø§Ù„ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ù…Ø®Ø²Ù†
    (function ensureInitial() {
      if (!localStorage.getItem('tiny.code')) {
        window.__TinyEditor.setCode(document.querySelector('#editor').textContent || '');
        // Ù„Ù… Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸: Ù†ØªØ±Ùƒ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø§Ù„Ù…Ø¶Ù…Ù† ÙÙŠ Editor init
      }
    })();
  </script>
</body>
</html>
