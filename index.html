<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TinyGameLang â€” Ù…Ø­Ø±Ø± + PixiJS (CodeMirror 5)</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- CodeMirror 5 (CSS + JS) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/eclipse.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <!-- Optional simple modes for highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>

  <!-- PixiJS -->
  <script src="https://pixijs.download/release/pixi.min.js"></script>

  <style>
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .cm-wrap { height:320px; border-radius:.5rem; overflow:hidden; border:1px solid #e5e7eb; }
    .codemirror { height:320px; }
    pre.console { background:#000; color:#9be15d; padding:10px; height:140px; overflow:auto; border-radius:.5rem; }
    /* ensure pixi canvas is responsive in container */
    #pixiContainer canvas { width:100% !important; height:320px !important; display:block; }
  </style>
</head>
<body class="bg-gray-50 min-h-screen p-6">

  <div class="max-w-6xl mx-auto">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">ğŸ® TinyGameLang â€” Ù…Ø­Ø±Ø± + Ø¹Ø±Ø¶ (PixiJS)</h1>
      <p class="text-sm text-gray-600">Ù†Ø³Ø®Ø© ØªØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠÙ‹Ø§ Ùˆ Ø¹Ù„Ù‰ GitHub Pages â€” Ù…Ø­Ø±Ø± CodeMirror 5 + PixiJS + Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ + ØªØµØ¯ÙŠØ±/Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø£Ù…Ø«Ù„Ø©.</p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Ø§Ù„Ù…Ø­Ø±Ø± ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª -->
      <section class="space-y-4">
        <div class="bg-white p-4 rounded-2xl shadow">
          <div class="flex items-start justify-between gap-3">
            <div>
              <h2 class="font-semibold">Ø§Ù„Ù…Ø­Ø±Ø±</h2>
              <p class="text-xs text-gray-500">Ø­Ø±Ø± ÙƒÙˆØ¯ TinyGameLang Ø«Ù… Ø§Ø¶ØºØ· ØªØ´ØºÙŠÙ„</p>
            </div>

            <div class="flex gap-2">
              <button id="runBtn" class="px-3 py-1 bg-green-600 text-white rounded">ØªØ´ØºÙŠÙ„</button>
              <button id="stopBtn" class="px-3 py-1 bg-red-500 text-white rounded">Ø¥ÙŠÙ‚Ø§Ù</button>
              <button id="saveBtn" class="px-3 py-1 bg-blue-600 text-white rounded">Ø­ÙØ¸ ÙŠØ¯ÙˆÙŠ</button>
              <button id="downloadBtn" class="px-3 py-1 bg-gray-200 rounded">ØªÙ†Ø²ÙŠÙ„ .tiny</button>
              <label class="cursor-pointer px-3 py-1 bg-gray-200 rounded">
                ØªØ­Ù…ÙŠÙ„
                <input id="uploadFile" type="file" accept=".tiny,.txt" class="hidden" />
              </label>
            </div>
          </div>

          <div class="mt-3 cm-wrap">
            <!-- textarea will be converted to CodeMirror -->
            <textarea id="codeArea" class="w-full h-full" spellcheck="false"></textarea>
          </div>

          <div class="mt-3 flex gap-2 items-center">
            <select id="examples" class="px-3 py-1 rounded border">
              <option value="">â€” Ø§Ø®ØªØ± Ù…Ø«Ø§Ù„Ø§Ù‹ â€”</option>
              <option value="basic">Ù…Ø«Ø§Ù„: Ø­Ø±ÙƒØ© Ø¨Ø³ÙŠØ·Ø©</option>
              <option value="background">Ù…Ø«Ø§Ù„: Ø®Ù„ÙÙŠØ© ÙˆÙ†Øµ</option>
              <option value="circle">Ù…Ø«Ø§Ù„: Ø¯Ø§Ø¦Ø±Ø© Ù…ØªØ­Ø±ÙƒØ©</option>
            </select>
            <button id="loadExample" class="px-3 py-1 bg-indigo-600 text-white rounded">ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„</button>

            <div class="mr-auto text-sm text-gray-500">Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙŠØ¹Ù…Ù„ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ.</div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ù…Ø®Ø±Ø¬Ø§Øª / Console</h3>
          <pre id="console" class="console mt-2">â€”</pre>
          <div class="mt-3 text-xs text-gray-500">Ø£Ø®Ø·Ø§Ø¡ Ø²Ù…Ù† Ø§Ù„ØªØ´ØºÙŠÙ„ ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§.</div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ø®ØªØµØ±Ø© Ù„Ù„Ù€ TinyGameLang</h3>
          <ul class="list-disc pr-5 mt-2 text-sm leading-7">
            <li><code>player at X Y</code> â€” Ø¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª</li>
            <li><code>color player NAME</code> â€” Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø§Ø³Ù… Ø£Ùˆ #hex)</li>
            <li><code>rect player W H</code> â€” Ø­Ø¬Ù… Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„</li>
            <li><code>circle player R</code> â€” Ø¯Ø§Ø¦Ø±Ø© Ø¨Ù†ØµÙ Ù‚Ø·Ø± R</li>
            <li><code>move player DX DY</code> â€” ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù„Ø§Ø¹Ø¨</li>
            <li><code>loop N ... end</code> â€” ÙƒØ±Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø© N Ù…Ø±Ø©</li>
            <li><code>background COLOR</code> â€” ØºÙŠÙ‘Ø± Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©</li>
            <li><code>say "text"</code> â€” Ø¹Ø±Ø¶ Ù†Øµ ÙÙˆÙ‚ Ø§Ù„Ù„Ø§Ø¹Ø¨</li>
          </ul>
        </div>
      </section>

      <!-- Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¨ØµØ±ÙŠØ© -->
      <section class="space-y-4">
        <div class="bg-white p-4 rounded-2xl shadow">
          <div class="flex items-center justify-between">
            <h2 class="font-semibold">Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (PixiJS)</h2>
            <div class="flex gap-2 items-center">
              <label class="flex items-center gap-2 text-sm">
                Ø­Ø¬Ù… Ø§Ù„Ø¹Ø±Ø¶
                <select id="sizeSelect" class="px-2 py-1 rounded border">
                  <option value="480x320">480Ã—320</option>
                  <option value="640x360">640Ã—360</option>
                  <option value="800x450">800Ã—450</option>
                </select>
              </label>
              <label class="flex items-center gap-2 text-sm">
                FPS:
                <span id="fps" class="ml-2 text-xs text-gray-500">â€”</span>
              </label>
            </div>
          </div>

          <div id="stageWrap" class="mt-3 border border-gray-200 rounded overflow-hidden" style="background:#ffffff">
            <div id="pixiContainer" style="width:100%;height:320px"></div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow">
          <h3 class="font-medium">Ø®ÙŠØ§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</h3>
          <div class="mt-3 grid grid-cols-2 gap-3">
            <label class="flex items-center gap-2"><input id="autoSaveToggle" type="checkbox" checked/> Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ</label>
            <label class="flex items-center gap-2">Ø³Ø±Ø¹Ø© Ø§Ù„ØªÙ†ÙÙŠØ°: <input id="speedRange" type="range" min="0.2" max="4" value="1" step="0.1" /></label>
            <label class="flex items-center gap-2">ØªØµÙÙŠØ± Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ <button id="clearConsole" class="px-2 py-1 bg-gray-200 rounded">Ù…Ø³Ø­</button></label>
            <div></div>
          </div>
        </div>

        <div class="bg-white p-4 rounded-2xl shadow text-sm text-gray-600">
          <strong>Ù…Ù„Ø§Ø­Ø¸Ø© Ù†Ø´Ø±:</strong> Ø¶Ø¹ Ø§Ù„Ù…Ù„Ù Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆØ¯Ø¹ ÙˆÙØ¹Ù‘Ù„ Pages (Ø§Ù„ÙØ±Ø¹ mainØŒ Ø§Ù„Ù…ØµØ¯Ø± /) ÙˆØ³ÙŠØ¹Ù…Ù„ Ù…Ø¨Ø§Ø´Ø±Ø©.
        </div>
      </section>
    </main>
  </div>

  <!-- --------- Script logic (no modules) ---------- -->
  <script>
    // ========== Init CodeMirror 5 ==========
    const defaultCode = `// Ù…Ø«Ø§Ù„ Ù…ÙˆØ³Ù‘Ø¹: TinyGameLang
background #222
player at 50 140
color player cyan
rect player 24 24
say "Ù…Ø±Ø­Ø¨Ø§Ù‹!"
loop 120
  move player 2 0
end
`;
    // textarea fallback content
    const ta = document.getElementById('codeArea');
    ta.value = localStorage.getItem('tiny.code') || defaultCode;

    const editor = CodeMirror.fromTextArea(ta, {
      mode: "javascript",   // use javascript mode for basic highlighting
      theme: "eclipse",
      lineNumbers: true,
      indentUnit: 2,
      tabSize: 2,
      smartIndent: true,
      autofocus: true
    });

    // helper API
    function getCode() { return editor.getValue(); }
    function setCode(txt) { editor.setValue(txt); }

    // ========== DOM refs ==========
    const runBtn = document.getElementById('runBtn');
    const stopBtn = document.getElementById('stopBtn');
    const saveBtn = document.getElementById('saveBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const uploadFile = document.getElementById('uploadFile');
    const loadExampleBtn = document.getElementById('loadExample');
    const examplesSelect = document.getElementById('examples');
    const consoleEl = document.getElementById('console');
    const autoSaveToggle = document.getElementById('autoSaveToggle');
    const sizeSelect = document.getElementById('sizeSelect');
    const pixiContainer = document.getElementById('pixiContainer');
    const fpsEl = document.getElementById('fps');
    const clearConsoleBtn = document.getElementById('clearConsole');
    const speedRange = document.getElementById('speedRange');

    // ========== Examples ==========
    const examples = {
      basic: `// Ø­Ø±ÙƒØ© Ø¨Ø³ÙŠØ·Ø©
background #111
player at 50 140
color player orange
rect player 24 24
loop 200
  move player 3 0
end
`,
      background: `background blue
player at 20 40
color player white
rect player 24 24
say "Ø®Ù„ÙÙŠØ© Ø²Ø±Ù‚Ø§Ø¡"
loop 120
  move player 2 0
end
`,
      circle: `background #0b0b0b
player at 100 150
color player #f0f
circle player 16
loop 180
  move player 2 0
end
`
    };

    loadExampleBtn.addEventListener('click', () => {
      const k = examplesSelect.value;
      if (!k) return alert('Ø§Ø®ØªØ± Ù…Ø«Ø§Ù„Ø§Ù‹');
      setCode(examples[k] || '');
    });

    // ========== Save / Load functionality ==========
    saveBtn.addEventListener('click', () => {
      localStorage.setItem('tiny.code', getCode());
      logConsole('ØªÙ… Ø§Ù„Ø­ÙØ¸ Ù…Ø­Ù„ÙŠØ§Ù‹');
    });

    // auto-save every 5s if enabled
    setInterval(() => {
      if (autoSaveToggle.checked) {
        try { localStorage.setItem('tiny.code', getCode()); }
        catch(e) { /* ignore storage errors */ }
      }
    }, 5000);

    uploadFile.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => { setCode(String(r.result)); };
      r.readAsText(f);
    });

    downloadBtn.addEventListener('click', () => {
      const code = getCode();
      const blob = new Blob([code], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'project.tiny';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    clearConsoleBtn.addEventListener('click', () => { consoleEl.textContent = ''; });

    function logConsole(msg) {
      consoleEl.textContent += msg + '\\n';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    // ========== TinyGameLang parser (light) ==========
    function parseTiny(src) {
      const lines = src.split(/\\r?\\n/);
      const root = [];
      const stack = [];
      for (let raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith('//')) continue;
        const sayMatch = line.match(/^say\\s+"(.*)"$/i);
        if (sayMatch) {
          const node = { t: 'say', text: sayMatch[1] };
          addNode(node);
          continue;
        }
        const parts = line.split(/\\s+/);
        const first = parts[0].toLowerCase();
        if (first === 'loop') {
          const n = Number(parts[1]) || 0;
          const node = { t: 'loop', n, body: [] };
          addNode(node);
          stack.push(node);
          continue;
        }
        if (first === 'end') {
          stack.pop();
          continue;
        }
        // other nodes
        let node = null;
        if (first === 'background') node = { t: 'background', color: parts[1] };
        else if (first === 'player' && parts[1] === 'at') node = { t: 'player_at', x: Number(parts[2]) || 0, y: Number(parts[3]) || 0 };
        else if (first === 'color' && parts[1] === 'player') node = { t: 'color_player', color: parts[2] };
        else if (first === 'rect' && parts[1] === 'player') node = { t: 'rect_player', w: Number(parts[2]) || 24, h: Number(parts[3]) || 24 };
        else if (first === 'circle' && parts[1] === 'player') node = { t: 'circle_player', r: Number(parts[2]) || 8 };
        else if (first === 'move' && parts[1] === 'player') node = { t: 'move_player', dx: Number(parts[2]) || 0, dy: Number(parts[3]) || 0 };
        else node = { t: 'unknown', raw: line };

        addNode(node);
      }

      function addNode(node) {
        if (stack.length > 0) stack[stack.length - 1].body.push(node);
        else root.push(node);
      }

      return root;
    }

    // flatten into frames
    function flattenCommands(cmds) {
      const frames = [];
      function push(list) {
        for (const n of list) {
          if (n.t === 'loop') {
            for (let i=0;i<n.n;i++) push(n.body);
          } else frames.push(n);
        }
      }
      push(cmds);
      return frames;
    }

    // ========== Pixi runtime ==========
    let app = null;
    let runtime = { running:false, speed:1 };

    function createPixi(w=480,h=320) {
      if (app) {
        app.destroy(true, { children: true });
        app = null;
        pixiContainer.innerHTML = '';
      }
      app = new PIXI.Application({ width:w, height:h, backgroundColor: 0x000000, resolution: window.devicePixelRatio || 1, autoDensity: true });
      pixiContainer.appendChild(app.view);
      app.renderer.view.style.width = '100%';
      app.renderer.view.style.height = '320px';
      return app;
    }

    function colorToHex(c) {
      if (!c) return 0xffffff;
      if (c.startsWith('#')) return parseInt(c.slice(1),16);
      const map = { red:0xff0000, green:0x00ff00, blue:0x0000ff, white:0xffffff, black:0x000000, cyan:0x00ffff, orange:0xffa500, yellow:0xffff00, magenta:0xff00ff, gray:0x808080, blueviolet:0x8a2be2 };
      return map[c.toLowerCase()] || 0xffffff;
    }

    function startRuntime(code) {
      const ast = parseTiny(code);
      const size = sizeSelect.value.split('x').map(Number);
      createPixi(size[0], size[1]);

      const stage = app.stage;
      const player = { g: new PIXI.Graphics(), x:0, y:0, w:24, h:24, r:null, color:0xffffff };
      stage.addChild(player.g);

      const texts = [];
      let bg = 0x000000;
      app.renderer.backgroundColor = bg;

      const frames = flattenCommands(ast);
      let pc = 0;

      function applyNode(node) {
        switch (node.t) {
          case 'background':
            bg = colorToHex(node.color); app.renderer.backgroundColor = bg; break;
          case 'player_at':
            player.x = node.x; player.y = node.y; break;
          case 'color_player':
            player.color = colorToHex(node.color); break;
          case 'rect_player':
            player.w = node.w; player.h = node.h; player.r = null; break;
          case 'circle_player':
            player.r = node.r; if (player.r) { player.w = player.h = player.r*2; } break;
          case 'move_player':
            player.x += node.dx * runtime.speed; player.y += node.dy * runtime.speed; break;
          case 'say':
            const t = new PIXI.Text(node.text, { fontSize: 16, fill: 0xffffff });
            t.x = player.x; t.y = player.y - 30; stage.addChild(t); texts.push({ obj: t, ttl: 120 }); break;
          case 'unknown':
            logConsole('ØªØ¹Ø°Ø± ØªÙ†ÙÙŠØ°: ' + node.raw); break;
        }
      }

      runtime.running = true;
      let last = performance.now();
      let fc = 0, ft = 0;

      app.ticker.add(() => {
        if (!runtime.running) return;
        const now = performance.now(); const dt = now - last; last = now;

        // execute a few nodes per tick (depends on speed)
        const perTick = Math.max(1, Math.round(runtime.speed));
        for (let k=0;k<perTick;k++) {
          if (pc >= frames.length) break;
          applyNode(frames[pc++]);
        }

        // draw player
        player.g.clear(); player.g.beginFill(player.color || 0xffffff);
        if (player.r) player.g.drawCircle(player.x + player.r, player.y + player.r, player.r);
        else player.g.drawRect(player.x, player.y, player.w, player.h);
        player.g.endFill();

        // update texts
        for (let i=texts.length-1;i>=0;i--) {
          texts[i].ttl--; texts[i].obj.x = player.x; texts[i].obj.y = player.y - 30;
          if (texts[i].ttl <= 0) { stage.removeChild(texts[i].obj); texts.splice(i,1); }
        }

        if (pc >= frames.length) {
          runtime.running = false;
          logConsole('Ø§Ù†ØªÙ‡Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª');
        }

        // fps
        fc++; ft += dt;
        if (ft >= 500) {
          const fps = Math.round((fc/ft)*1000);
          fpsEl.textContent = fps + ' fps';
          fc = 0; ft = 0;
        }
      });

      logConsole('Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ â€” ' + frames.length + ' Ø¹Ù…Ù„ÙŠØ©');
    }

    function stopRuntime() {
      runtime.running = false;
      if (app && app.ticker) {
        // don't destroy canvas, just stop performing changes
      }
      logConsole('Ø£ÙÙˆÙ‚Ù Ø§Ù„ØªÙ†ÙÙŠØ°');
    }

    // ========== Buttons wiring ==========
    runBtn.addEventListener('click', () => {
      stopRuntime();
      consoleEl.textContent = '';
      try {
        startRuntime(getCode());
      } catch (e) { logConsole('Ø®Ø·Ø£: ' + e.message); }
    });

    stopBtn.addEventListener('click', () => { stopRuntime(); });

    // resize stage on change
    sizeSelect.addEventListener('change', () => {
      const s = sizeSelect.value.split('x').map(Number);
      if (app) app.renderer.resize(s[0], s[1]);
    });

    // speed slider
    speedRange.addEventListener('input', () => { runtime.speed = Number(speedRange.value); });

    // on load: ensure editor has initial value
    (function init() {
      if (!localStorage.getItem('tiny.code')) {
        setCode(defaultCode);
      }
      logConsole('Ø¬Ø§Ù‡Ø² â€” Ø¹Ø¯Ù‘Ù„ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ§Ø¶ØºØ· ØªØ´ØºÙŠÙ„');
    })();

    // Make editor focusable quickly
    editor.focus();
  </script>
</body>
</html>
